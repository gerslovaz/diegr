if (missing(hemisphere)) {
idx <- 1:length(x)
}
if (missing(region)) {
new.coords <- coords$D2[idx,]
}
if (missing(ROI)) {
ROI <- ROIs
}
idx.reg <- grep(paste(region, collapse = "|"), ROI)
idx.reg <- na.omit(idx[idx.reg])
new.coords <- coords$D2[idx.reg,]
return(new.coords)
}
pick_region(region = "frontal")
plot(HCGSN256$D2, type = "n")
points(F1, col = "blue")
F1 <- pick_region(region = "frontal")
points(F1, col = "blue")
LF1 <- pick_region(region = "frontal", hemisphere = "left")
points(LF1, col = "red", pch = 16)
points(pick_region(hemisphere = "right", region = "frontal"), col = "black", pch = 16)
plot(HCGSN256$D2, type = "n")
F1 <- pick_region(region = c("frontal", "temporal"))
points(F1, col = "blue")
F1 <- pick_region(region = c("frontal", "temporal", "central"))
plot(HCGSN256$D2, type = "n")
points(F1, col = "blue")
points(pick_region(hemisphere = "left"), col = "red")
id1 <- c(3,2,1,6,9)
id2 <- c(3,6,8)
id1[id2]
pick_region <- function(coords = NULL, hemisphere = NULL, region = NULL, ROI = NULL) {
if (missing(coords)) {
coords <- HCGSN256
}
if (missing(ROI)) {
ROI <- ROIs
}
idx.reg <- grep(paste(region, collapse = "|"), ROI)
new.coords <- coords$D2[idx.reg,]
if (missing(region)) {
new.coords <- coords$D2
}
x <- new.coords$x
#midline <- which(x == 0)
idx.l <- c()
idx.r <- c()
if (any(hemisphere == "left")) {
idx.l <- which(x < 0)
}
if (any(hemisphere == "right")) {
idx.r <- which(x > 0)
}
idx <- c(idx.l, idx.r)
if (missing(hemisphere)) {
idx <- 1:length(new.coords)
}
new.coords <- new.coords[idx,]
return(new.coords)
}
F1 <- pick_region(region = c("frontal", "temporal", "central"))
plot(HCGSN256$D2, type = "n")
points(F1, col = "blue")
pick_region <- function(coords = NULL, hemisphere = NULL, region = NULL, ROI = NULL) {
if (missing(coords)) {
coords <- HCGSN256
}
if (missing(ROI)) {
ROI <- ROIs
}
idx.reg <- grep(paste(region, collapse = "|"), ROI)
new.coords <- coords$D2[idx.reg,]
if (missing(region)) {
new.coords <- coords$D2
}
x <- new.coords$x
#midline <- which(x == 0)
idx.l <- c()
idx.r <- c()
if (any(hemisphere == "left")) {
idx.l <- which(x < 0)
}
if (any(hemisphere == "right")) {
idx.r <- which(x > 0)
}
idx <- c(idx.l, idx.r)
if (missing(hemisphere)) {
idx <- 1:length(x)
}
new.coords <- new.coords[idx,]
return(new.coords)
}
F1 <- pick_region(region = c("frontal", "temporal", "central"))
plot(HCGSN256$D2, type = "n")
points(F1, col = "blue")
LF1 <- pick_region(region = "frontal", hemisphere = "left")
points(LF1, col = "red", pch = 16)
points(pick_region(hemisphere = "right", col = "black"))
points(pick_region(hemisphere = "right"), col = "black")
pick_region <- function(coords = NULL, hemisphere = NULL, region = NULL, ROI = NULL) {
if (missing(coords)) {
coords <- HCGSN256
}
if (missing(ROI)) {
ROI <- ROIs
}
idx.reg <- grep(paste(region, collapse = "|"), ROI)
new.coords <- coords$D2[idx.reg,]
if (missing(region)) {
new.coords <- coords$D2
}
x <- new.coords$x
midline <- which(x == 0)
idx.l <- c()
idx.r <- c()
if (any(hemisphere == "left")) {
idx.l <- which(x < 0)
}
if (any(hemisphere == "right")) {
idx.r <- which(x > 0)
}
idx <- c(idx.l, idx.r, midline)
if (missing(hemisphere)) {
idx <- 1:length(x)
}
new.coords <- new.coords[idx,]
return(new.coords)
}
points(pick_region(hemisphere = "right"), col = "black")
str(F1)
F1 <- pick_region(region = "frontal")
Fmesh1 <- point_mesh(2, n = 3000)
#' @import sp
#' @import concaveman
#'
#' @export
#'
#' @examples
#' # Computing circle 2D mesh with starting number 4000 points for HCGSN256 template
#' M <- point_mesh(dim = 2, n = 4000, type = 'circle')
#' # Computing polygon 3D mesh with starting number 2000 points for HCGSN256 template
#' M <- point_mesh(dim = 3, n = 2000, type = 'polygon')
point_mesh <- function(dim, n = 10000, r, template = 'HCGSN256', type = 'circle') {
if (template == 'HCGSN256') {
coordinates <- HCGSN256
}
if (missing(r)) {
r <- ceiling(max(abs(range(coordinates$D2))))
}
N <- round(sqrt(2*n))
x.vec <- rep(seq(-r, r, length.out = N), N)
y.vec <- rep(seq(-r, r, length.out = N), each = N)
mesh.circle <- cbind(x.vec, y.vec)
eu.vec <- edist0(x.vec, y.vec)
out.vec <- which(eu.vec > r)
mesh.circle[out.vec,] <- NA
if (dim == 2) {
mesh.out <- data.frame(x = mesh.circle[,1], y = mesh.circle[,2])
}
if (type == 'polygon') {
mesh.polygon <- make_polygon(coordinates$D2 ,mesh.circle)
mesh.out <- data.frame(x = mesh.polygon[,1], y = mesh.polygon[,2])
if (dim == 3) {
mesh.out <- recompute_3d(coordinates$D2, coordinates$D3, mesh.polygon)
}
}
if (dim == 3 && type == 'circle') {
mesh.out <- recompute_3d(coordinates$D2, coordinates$D3, mesh.circle)
}
return(mesh.out)
}
Fmesh1 <- point_mesh(2, n = 3000)
make_polygon <- function(locations, mesh) {
## exclude points outside the defined polygon
coord.sf <- st_as_sf(locations, coords = c("x","y"))
concave.sf <- coord.sf %>%
summarise() %>%
concaveman::concaveman(concavity = 2)
polyg <- st_zm(concave.sf)
polyg.sp <- as_Spatial(polyg) # spatial polygon
coord.sp <- as_Spatial(coord.sf) # spatial points
square.sp <- sp::SpatialPoints(na.omit(mesh))
mesh.poly <- sp::point.in.polygon(square.sp@coords[,1], square.sp@coords[,2],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,1],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,2])
idx <- which(mesh.poly == 1)
mesh.wrap <- na.omit(mesh)[idx,]
mesh.polygon <- matrix(NA, N*N, 2)
mesh.poly.NA <- matrix(NA, N*N, 2)
mesh.poly.NA[-which(is.na(mesh.circle[,1])),] <- mesh.poly
mesh.polygon[which(mesh.poly.NA[,1] == 1),] <- mesh.wrap
return(mesh.polygon)
}
Fmesh.reg <- make_polygon(F1, Fmesh1)
make_polygon <- function(locations, mesh, N) {
## exclude points outside the defined polygon
coord.sf <- st_as_sf(locations, coords = c("x","y"))
concave.sf <- coord.sf %>%
summarise() %>%
concaveman::concaveman(concavity = 2)
polyg <- st_zm(concave.sf)
polyg.sp <- as_Spatial(polyg) # spatial polygon
coord.sp <- as_Spatial(coord.sf) # spatial points
square.sp <- sp::SpatialPoints(na.omit(mesh))
mesh.poly <- sp::point.in.polygon(square.sp@coords[,1], square.sp@coords[,2],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,1],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,2])
idx <- which(mesh.poly == 1)
mesh.wrap <- na.omit(mesh)[idx,]
mesh.polygon <- matrix(NA, N*N, 2)
mesh.poly.NA <- matrix(NA, N*N, 2)
mesh.poly.NA[-which(is.na(mesh.circle[,1])),] <- mesh.poly
mesh.polygon[which(mesh.poly.NA[,1] == 1),] <- mesh.wrap
return(mesh.polygon)
}
Fmesh.reg <- make_polygon(F1, Fmesh1, N = round(sqrt(2*2000)))
make_polygon <- function(locations, mesh, N) {
## exclude points outside the defined polygon
coord.sf <- st_as_sf(locations, coords = c("x","y"))
concave.sf <- coord.sf %>%
summarise() %>%
concaveman::concaveman(concavity = 2)
polyg <- st_zm(concave.sf)
polyg.sp <- as_Spatial(polyg) # spatial polygon
coord.sp <- as_Spatial(coord.sf) # spatial points
square.sp <- sp::SpatialPoints(na.omit(mesh))
mesh.poly <- sp::point.in.polygon(square.sp@coords[,1], square.sp@coords[,2],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,1],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,2])
idx <- which(mesh.poly == 1)
mesh.wrap <- na.omit(mesh)[idx,]
mesh.polygon <- matrix(NA, N*N, 2)
mesh.poly.NA <- matrix(NA, N*N, 2)
mesh.poly.NA[-which(is.na(mesh[,1])),] <- mesh.poly
mesh.polygon[which(mesh.poly.NA[,1] == 1),] <- mesh.wrap
return(mesh.polygon)
}
Fmesh.reg <- make_polygon(F1, Fmesh1, N = round(sqrt(2*2000)))
sqrt(4000)
63^2
dim(M)[1]
make_polygon <- function(locations, mesh, N) {
## exclude points outside the defined polygon
N <- dim(mesh)[1]
coord.sf <- st_as_sf(locations, coords = c("x","y"))
concave.sf <- coord.sf %>%
summarise() %>%
concaveman::concaveman(concavity = 2)
polyg <- st_zm(concave.sf)
polyg.sp <- as_Spatial(polyg) # spatial polygon
coord.sp <- as_Spatial(coord.sf) # spatial points
square.sp <- sp::SpatialPoints(na.omit(mesh))
mesh.poly <- sp::point.in.polygon(square.sp@coords[,1], square.sp@coords[,2],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,1],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,2])
idx <- which(mesh.poly == 1)
mesh.wrap <- na.omit(mesh)[idx,]
mesh.polygon <- matrix(NA, N*N, 2)
mesh.poly.NA <- matrix(NA, N*N, 2)
mesh.poly.NA[-which(is.na(mesh[,1])),] <- mesh.poly
mesh.polygon[which(mesh.poly.NA[,1] == 1),] <- mesh.wrap
return(mesh.polygon)
}
Fmesh.reg <- make_polygon(F1, Fmesh1, N = round(sqrt(2*2000)))
F1
plot(Fmesh1)
make_polygon <- function(locations, mesh) {
## exclude points outside the defined polygon
N <- dim(mesh)[1]
coord.sf <- st_as_sf(locations, coords = c("x","y"))
concave.sf <- coord.sf %>%
summarise() %>%
concaveman::concaveman(concavity = 2)
polyg <- st_zm(concave.sf)
polyg.sp <- as_Spatial(polyg) # spatial polygon
coord.sp <- as_Spatial(coord.sf) # spatial points
square.sp <- sp::SpatialPoints(na.omit(mesh))
mesh.poly <- sp::point.in.polygon(square.sp@coords[,1], square.sp@coords[,2],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,1],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,2])
idx <- which(mesh.poly == 1)
mesh.wrap <- na.omit(mesh)[idx,]
mesh.polygon <- matrix(NA, N*N, 2)
mesh.poly.NA <- matrix(NA, N*N, 2)
mesh.poly.NA[-which(is.na(mesh[,1])),] <- mesh.poly
mesh.polygon[which(mesh.poly.NA[,1] == 1),] <- mesh.wrap
return(mesh.polygon)
}
Fmesh.reg <- make_polygon(F1, Fmesh1, N = round(sqrt(2*2000)))
Fmesh.reg <- make_polygon(F1, Fmesh1)
## exclude points outside the defined polygon
N <- dim(mesh)[1]
mesh <- Fmesh1
## exclude points outside the defined polygon
N <- dim(mesh)[1]
coord.sf <- st_as_sf(locations, coords = c("x","y"))
locations <- F1
coord.sf <- st_as_sf(locations, coords = c("x","y"))
concave.sf <- coord.sf %>%
summarise() %>%
concaveman::concaveman(concavity = 2)
polyg <- st_zm(concave.sf)
polyg.sp <- as_Spatial(polyg) # spatial polygon
coord.sp <- as_Spatial(coord.sf) # spatial points
square.sp <- sp::SpatialPoints(na.omit(mesh))
mesh.poly <- sp::point.in.polygon(square.sp@coords[,1], square.sp@coords[,2],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,1],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,2])
idx <- which(mesh.poly == 1)
mesh.wrap <- na.omit(mesh)[idx,]
mesh.polygon <- matrix(NA, N*N, 2)
mesh.poly.NA <- matrix(NA, N*N, 2)
mesh.poly.NA[-which(is.na(mesh[,1])),] <- mesh.poly
str(mesh.poly)
str(mesh.wrap)
points(mesh.wrap, col = "red", pch = 16)
View(new.coords)
View(new.coords)
str(idx)
sum(which(mesh.poly == 0))
8231050 + 533
str(mesh)
N
make_polygon <- function(locations, mesh, N) {
## exclude points outside the defined polygon
N <- dim(mesh)[1]
coord.sf <- st_as_sf(locations, coords = c("x","y"))
concave.sf <- coord.sf %>%
summarise() %>%
concaveman::concaveman(concavity = 2)
polyg <- st_zm(concave.sf)
polyg.sp <- as_Spatial(polyg) # spatial polygon
coord.sp <- as_Spatial(coord.sf) # spatial points
square.sp <- sp::SpatialPoints(na.omit(mesh))
mesh.poly <- sp::point.in.polygon(square.sp@coords[,1], square.sp@coords[,2],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,1],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,2])
idx <- which(mesh.poly == 1)
mesh.wrap <- na.omit(mesh)[idx,]
mesh.polygon <- matrix(NA, N, 2)
mesh.poly.NA <- matrix(NA, N, 2)
mesh.poly.NA[-which(is.na(mesh[,1])),] <- mesh.poly
mesh.polygon[which(mesh.poly.NA[,1] == 1),] <- mesh.wrap
return(mesh.polygon)
}
Fmesh.reg <- make_polygon(F1, Fmesh1)
mesh.polygon <- matrix(NA, N, 2)
mesh.poly.NA <- matrix(NA, N, 2)
mesh.poly.NA[-which(is.na(mesh[,1])),] <- mesh.poly
mesh.polygon[which(mesh.poly.NA[,1] == 1),] <- mesh.wrap
length(na.omit(mesh$x))
length(mesh$x)
idx <- which(mesh.poly == 1)
dim(idx)
length(idx)
N
mesh.polygon <- matrix(NA, N, 2)
mesh.poly.NA <- matrix(NA, N, 2)
mesh.poly.NA[-which(is.na(mesh[,1])),] <- mesh.poly
mesh.polygon[which(mesh.poly.NA[,1] == 1),] <- mesh.wrap
str(mesh.polygon)
View(mesh.poly.NA)
mesh.poly.NA <- rep(0,N)
mesh.poly.NA[-which(is.na(mesh[,1])),] <- mesh.poly
mesh.poly.NA[-which(is.na(mesh[,1]))] <- mesh.poly
mesh.polygon[which(mesh.poly.NA[,1] == 1),] <- mesh.wrap
mesh.polygon[which(mesh.poly.NA == 1),] <- mesh.wrap
which(mesh.poly.NA == 1)
mesh.polygon <- matrix(NA, N, 2)
mesh.polygon[which(mesh.poly.NA == 1),] <- mesh.wrap
mesh.polygon <- matrix(NA, N, 2)
mesh.polygon[which(mesh.poly.NA == 1),1] <- mesh.wrap$x
mesh.polygon[which(mesh.poly.NA == 1),2] <- mesh.wrap$y
make_polygon <- function(locations, mesh, N) {
## exclude points outside the defined polygon
N <- dim(mesh)[1]
coord.sf <- st_as_sf(locations, coords = c("x","y"))
concave.sf <- coord.sf %>%
summarise() %>%
concaveman::concaveman(concavity = 2)
polyg <- st_zm(concave.sf)
polyg.sp <- as_Spatial(polyg) # spatial polygon
coord.sp <- as_Spatial(coord.sf) # spatial points
square.sp <- sp::SpatialPoints(na.omit(mesh))
mesh.poly <- sp::point.in.polygon(square.sp@coords[,1], square.sp@coords[,2],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,1],
polyg.sp@polygons[[1]]@Polygons[[1]]@coords[,2])
idx <- which(mesh.poly == 1)
mesh.wrap <- na.omit(mesh)[idx,]
mesh.polygon <- matrix(NA, N, 2)
mesh.poly.NA <- rep(0,N)
mesh.poly.NA[-which(is.na(mesh[,1]))] <- mesh.poly
mesh.polygon[which(mesh.poly.NA == 1),1] <- mesh.wrap$x
mesh.polygon[which(mesh.poly.NA == 1),2] <- mesh.wrap$y
return(mesh.polygon)
}
Fmesh.reg <- make_polygon(F1, Fmesh1)
plot(Fmesh.reg)
plot(Fmesh1)
plot(Fmesh1, cex = 0.4)
plot(Fmesh1, cex = 0.4, col = "gray", pch = 16)
points(Fmesh.reg, col = "red", cex = 0.5)
points(make_polygon(pick_region(hemisphere = "left"), Fmesh1), col = "blue", pch = 0.6)
points(HCGSN256$D2, col = "black", pch = 16, cex = 0.4)
points(pick_region(hemisphere = "left"), col = "purple", pch = 1, cex = 0.5)
?sp::point.in.polygon
?st_intersects
install.packages("ptinpoly")
library(ptinpoly)
poly.vertices <- data.frame(x=c(20,40,80,50,40,30), y=c(30,20,70,80,50,60))
p <- data.frame(x=runif(100, min=0, max=100), y=runif(100, min=0, max=100))
outside <- (pip2d(as.matrix(poly.vertices), as.matrix(p)) < 0)
plot(p$x, p$y, col=ifelse(outside, "red", "black"))
polygon(poly.vertices$x, poly.vertices$y, border="blue", col=NA)
poly.vertices <- F1
?pip2d
p <- Fmesh1
outside <- (pip2d(as.matrix(poly.vertices), as.matrix(p)) < 0)
outside <- (pip2d(as.matrix(poly.vertices), as.matrix(na.omit(p))) < 0)
plot(p$x, p$y, col=ifelse(outside, "red", "black"))
polygon(poly.vertices$x, poly.vertices$y, border="blue", col=NA)
p <- na.omit(Fmesh1)
outside <- (pip2d(as.matrix(poly.vertices), as.matrix(p)) < 0)
plot(p$x, p$y, col=ifelse(outside, "red", "black"))
polygon(poly.vertices$x, poly.vertices$y, border="blue", col=NA)
blk <- coord.sf
# Convert to multipoint
blk_mp <- st_combine(blk)
# Define convex hull
blk_poly <- st_convex_hull(blk_mp)
black <- locations
plot(black)
points(red, col = "red")
plot(blk_poly, add = TRUE)
red <- Fmesh1
points(red, col = "red")
rd <- st_as_sf(red, coords = c("x", "y"))
red <- na.omit(Fmesh1)
rd <- st_as_sf(red, coords = c("x", "y"))
rd_inside <- st_intersection(rd, blk_poly)
plot(black)
points(red)
plot(blk_poly, add = TRUE)
plot(rd_inside, pch = 24, col = "red", bg = "red", add = TRUE)
# Convert df to point feature
black <- pick_region(hemisphere = "left")
blk <- st_as_sf(black, coords = c("x", "y"))
# Convert to multipoint
blk_mp <- st_combine(blk)
# Define convex hull
blk_poly <- st_convex_hull(blk_mp)
plot(black)
red <- na.omit(Fmesh1)
points(red, col = "red")
plot(blk_poly, add = TRUE)
rd <- st_as_sf(red, coords = c("x", "y"))
rd_inside <- st_intersection(rd, blk_poly)
plot(black)
points(red)
plot(blk_poly, add = TRUE)
plot(rd_inside, pch = 24, col = "red", bg = "red", add = TRUE)
head(rd_inside)
c1 <- st_coordinates(rd_inside)
View(c1)
plot(c1, col = "blue", add = TRUE)
View(rd_inside)
View(rd)
str(mesh)
roi <- st_as_sf(locations, coords = c("x", "y"))
roi.mp <- st_combine(roi)
roi.poly <- st_convex_hull(roi.mp) # Define convex hull
mesh <- na.omit(mesh)
mesh.sf <- st_as_sf(mesh, coords = c("x", "y"))
mesh.inside <- st_intersection(mesh.sf, roi.poly)
mesh.inside <- st_coordinates(mesh_inside)
mesh.inside <- st_coordinates(mesh.inside)
mesh.polygon <- mesh[which(!is.na(mesh$x)),] <- mesh.inside
N <- dim(mesh)[1]
str(mesh)
mesh.polygon <- matrix(NA, N, 2)
mesh.polygon[-which(is.na(mesh$x)),] <- mesh.inside
plot(mesh.polygon, col = "black", pch = 3)
View(mesh.polygon)
plot(na.omit(mesh.polygon), col = "black", pch = 3)
min(mesh.polygon)
min(na.omit(mesh.polygon))
min(mesh.inside)
max(mesh.inside)
which(!is.na(mesh$x))[1:5]
which(!is.na(mesh$x))
?unique
head(mesh.inside)
x <- unique(mesh.inside$x)
x <- unique(mesh.inside$X)
mesh.inside[1]
mesh.inside[2]
View(mesh.inside)
x <- unique(mesh.inside[,1])
y <- unique(mesh.inside[,2])
y
x <- unique(mesh.inside[,1])
y <- unique(mesh.inside[,2])
nx <- length(x)
ny <- length(y)
x.seq <- rep(x, ny)
y.seq <- rep(y, each = nx)
ctverec <- cbind(x.seq, y.seq)
plot(ctverec, pch = 0.5)
plot(ctverec, cex = 0.5)
points(mesh.inside, col = "red", cex = 0.5)
points(mesh.inside, col = "red", cex = 0.5, pch = 16)
