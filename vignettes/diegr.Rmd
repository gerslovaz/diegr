---
title: "diegr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{diegr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(diegr)
library(rlang)
```

### Data

The package contains built-in data sets. Due to the nature of the experiment and the size of the data, this is only a small section which serves as a demonstration of the implemented functions and it is not possible to reconstruct the real signal of a specific subject from it. 

#### epochdata
The brain signal originally measured by 256-channel HydroCel Geodesic Sensor Net with sampling frequency 250 Hz. 
Example dataset contains amplitude values from chosen 204 channels in 50 time points (with the stimulus in the time point 10) for 2 representative subjects (one from patient, one from health control group). From the total number of 50 epochs for each subject, 14 (or 15) epochs were selected.

The data is organized into a data frame with the following columns:
- time: Number of time point. Number 10 indicates the time of stimulus (0 ms), the interval between two time points corresponds to the time period 4 ms (according to sampling frequency 250 Hz).
- signal: HD-EEG signal amplitude (in microvolts).
- epoch: Epoch number (there are 14 epochs for subject one, 15 epochs for subject two).
- sensor: Sensor label (labeling corresponds to the EGI Geodesic Sensor Net Technical Manual).
- subject: Subject ID (1 - representative health control subject, 2 - representative patient subject).

#### HCGSN256

The Cartesian coordinates of high-density EEG sensor positions in 3D space on the scalp surface and their projection into 2D space according to 256-channel HydroCel Geodesic Sensor Net average template montage.

The data is organized into a list with the following elements:
- sensor: Sensor label (according to EGI GSN Technical Manual, the same as in `epochdata`).
- D2: A tibble with coordinates of sensors in 2D.
- D3: A tibble with coordinates of sensors in 3D. 
- ROI: The name of the region to which the corresponding sensor belongs (one of "central", "frontal", "occipital", "parietal" or "temporal").
- pairedname: Alternative sensor labels corresponding to left/right paired electrodes (with C for midline).

Note: 
The axis orientation in the 3D case is as follows: the x axis runs left (negative) to right (positive); the y axis runs posterior (negative) to anterior (positive); and the z axis runs inferior (negative) to superior (positive). 

#### rtdata

The response time values in individual experiment epochs for 2 representative subjects (one from patient, one from health control group). The epochs and subjects correspond to the sample dataset `epochdata`.

The data is organized into a data frame with the following columns:
- subject: Subject ID (1 - representative health control subject, 2 - representative patient subject).
- epoch: Epoch number (there are 14 epochs for subject one, 15 epochs for subject two).
- RT: Response time in ms.

### křivky

### Spatial Visualization - topo mapy? jak to budem pojmenovávat?

#### Mesh Generation for Spatial Visualization
The original electrode grid is too coarse for graphical rendering. To achieve smoother and more visually appealing results in plots, it's necessary to generate a denser mesh of points. This refined mesh provides better spatial resolution and enhances the quality of visualizations.
Creating a new mesh is available through `point_mesh` function. This function computes the coordinates of mesh in 2D and/or 3D and enables to control a density (argument `n`) or the shape (argument `type`) of the result mesh. 
The default setting creates a polygonal mesh with starting number 10000 points and computes the coordinates in both dimensions, which are available in `$D2` and `$D3` parts of a result list (class `"mesh"`).
For simple created mesh plotting use the function `plot_point_mesh`, which results in two dimensional \code{ggplot} of point mesh or three dimensional \code{rgl} plot depending on the input dimension. 
Notes: 
- The input of `plot_point_mesh` must be only the relevant part with coordinates - `$D2` for two dimensional and `$D3` for three dimensional plot.
- 
Pokud je počet bodů sítě už hodně velký, už nejsou v grafu patrné a síť vypadá jako jednolitá plocha. 


```{r}
## creating a mesh with default settings
M1 <- point_mesh(template = "HCGSN256")
## plot output in 2D
plot_point_mesh(M1$D2)
```

```{r}
## creating a denser circular mesh, only 2D coordinates
M2 <- point_mesh(n = 30000, template = "HCGSN256", type = "circle")
## plotting a mesh - function allows different options of the result plot
plot_point_mesh(M2$D2, col.sensors = "purple", names = TRUE, cex = 0.1)
```

The graphic functions in `diegr` allow also the user to input the custom mesh created in other way, it is only necessary to maintain the structure following a `"mesh"` object. 

#### Topographical maps in 2D projection

#### Topographical maps on the scalp

The `scalp_plot` function is created for plotting a scalp polygon map of the EEG signal amplitude using topographic colour scale (with zero value always at the border of blue and green shades). The result plot is rendered using \code{\link[rgl]{shape3d}} function and the signal interpolation between sensor locations is based on thin-plate spline interpolation model \eqn{\text{IM:}\; \mathbb{R}^3 \rightarrow \mathbb{R}}. 
The function allows setting the `col.range` argument, which is neccessary to obtain comparable results between different subjects or conditions. 
Note: The input values of `signal` outside the chosen `col.range` will cause "holes" in the resulting plot.

```{r}
# preparing data - filtering signal from time point 10 (time of the stimulus) for subject 2,
# computing average from all epochs without outliers 14 and 15
s1 <- epochdata |>
dplyr::filter(.data$time == 10 & .data$subject == 2 & !.data$epoch %in% c(14,15)) |>
dplyr::select("signal", "sensor", "epoch") |>
dplyr::group_by(.data$sensor) |>
dplyr::mutate(average = mean(.data$signal, na.rm = TRUE))
s1 <- s1$average[1:204]

# plotting the scalp polygon map
#open3d()
scalp_plot(signal = s1, col.range = c(-30, 15))
```

popsat defaultní natočení obr. a možnost rotace




