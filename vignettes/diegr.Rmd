---
title: "diegr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{diegr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(rgl)
knitr::knit_hooks$set(webgl = hook_webgl)
```

```{r setup}
#| echo: false
library(diegr)
library(rlang)
```

The package `diegr` displays high-density electroencephalography (HD-EEG) data in different ways using interactive elements or animations for a comprehensive overview of data.

### Installation

You can install the development version of diegr from GitHub with:

```{r}
#| eval: false
# install.packages("devtools")
devtools::install_github("gerslovaz/diegr")
```

### Data

The package contains built-in datasets. Due to the nature of the experiment and the size of the data, this is only a small section which serves as a demonstration of the implemented functions and it is not possible to reconstruct the real signal of a specific subject from it. 

#### epochdata
The brain signal originally measured by 256-channel HydroCel Geodesic Sensor Net with sampling frequency 250 Hz. 
Example dataset contains amplitude values from chosen 204 channels in 50 time points (with the stimulus in the time point 10) for 2 representative subjects (one from patient, one from health control group). From the total number of 50 epochs for each subject, 14 (or 15) epochs were selected.

The data is organized into a data frame with the following columns:

- `time`: Number of time point. Number 10 indicates the time of stimulus (0 ms), the interval between two time points corresponds to the time period 4 ms (according to sampling frequency 250 Hz).
- `signal`: HD-EEG signal amplitude (in microvolts).
- `epoch`: Epoch number (there are 14 epochs for subject one, 15 epochs for subject two).
- `sensor`: Sensor label (labeling corresponds to the EGI Geodesic Sensor Net Technical Manual).
- `subject`: Subject ID (1 - representative health control subject, 2 - representative patient subject).

#### HCGSN256

The Cartesian coordinates of high-density EEG sensor positions in 3D space on the scalp surface and their projection into 2D space according to 256-channel HydroCel Geodesic Sensor Net average template montage.

The data is organized into a list with the following elements:

- `sensor`: Sensor label (according to EGI GSN Technical Manual, the same as in `epochdata`).
- `D2`: A tibble with coordinates of sensors in 2D.
- `D3`: A tibble with coordinates of sensors in 3D. 
- `ROI`: The name of the region to which the corresponding sensor belongs (one of "central", "frontal", "occipital", "parietal" or "temporal").
- `pairedname`: Alternative sensor labels corresponding to left/right paired electrodes (with C for midline).

Note: 
The axis orientation in the 3D case is as follows: 

- the x axis runs left (negative) to right (positive);
- the y axis runs posterior (negative) to anterior (positive); 
- the z axis runs inferior (negative) to superior (positive). 

#### rtdata

The response time values in individual experiment epochs for 2 representative subjects (one from patient, one from health control group). The epochs and subjects correspond to the sample dataset `epochdata`.

The data is organized into a data frame with the following columns:

- `subject`: Subject ID (1 - representative health control subject, 2 - representative patient subject).
- `epoch`: Epoch number (there are 14 epochs for subject one, 15 epochs for subject two).
- `RT`: Response time in ms.

### Tools useful in preprocessing

The package assumes that the input data has already been preprocessed (artifacts removed, ICA and segmentation performed, etc.), but it may still contain outliers that need to be discarded for some statistical and analytic issues. 

The useful tool in outliers detection is interactive plot with boxplots of amplitudes (`boxplot_epoch`) or response times (`boxplot_rt`) in individual epochs. The `plotly` output enables to easily determine the epoch number from which outliers come and additionally allows editing of the output image layout.

There is also an interactive graph of amplitudes in individual epochs with the average plotted (`interactive_waveforms`).

```{r}
# in interactive boxplot of signal we choose subject, 
# channel and concrete time range,
# in which the boxplots should be plotted
# example for subject 1 and channel E34 in time points from 10 to 20
boxplot_epoch(epochdata, subject = 1, channel = "E34", time_lim = c(10:20))
```

By using the hoover text in the plotly output, we can easily see that the epoch 14 is significantly outlier for this channel.

```{r}
#| eval: false
# customizing the output title and axis labels using |> operator
p1 <- boxplot_epoch(epochdata, subject = 1, channel = "E34", 
                    time_lim = c(10:20))
p1 |> plotly::layout(xaxis = list(title = ""),
                     yaxis = list(title = "Amplitude"),
                     title = list(text = "Outlier detection for subject 1 and channel E34",
                                  font = list(size = 11, color = "darkblue"))
                     )
# note: the output is not plotted to keep the vignette size reasonable
```

The results can be supported computationally by the `outliers_epoch` function, which allows the evaluation of outliers using one of three criteria (interquartile range - IQR, percentile approach or Hampel filter).  
The output of this function is a table containing epoch IDs and the number of time points in which the epochs were evaluated as outliers (according to chosen criteria).

```{r}
# outlier detection for subject 1 and channel E34 using IQR method
outliers_epoch(epochdata, subject = 1, sensor = "E34", method = "iqr")
```

The results correspond with findings from `boxplot_epoch` - the epoch 14 was evaluated as an outlier in all 50 time points.

### Spatial Visualization 

#### Mesh Generation
The original electrode grid is too coarse for graphical rendering. To achieve smoother and more visually appealing results in plots, it's necessary to generate a denser mesh of points. This refined mesh provides better spatial resolution and enhances the quality of visualizations.
Creating a new mesh is available through `point_mesh` function. This function computes the coordinates of mesh in 2D and/or 3D and enables to control a density (argument `n`) or the shape (argument `type`) of the result mesh.  
The default setting creates a polygonal mesh with starting number 10000 points and computes the coordinates in both dimensions, which are available in `$D2` and `$D3` parts of a result list (class `"mesh"`).

For simple created mesh plotting use the function `plot_point_mesh`, which results in two dimensional \code{ggplot} of point mesh or three dimensional \code{rgl} plot depending on the input dimension. 

Notes: 

- The input of `plot_point_mesh` must be only the relevant part with coordinates - `$D2` for two dimensional and `$D3` for three dimensional plot.
- If the number of mesh points is large, they are no longer visible in the plot and the mesh looks like a solid surface.


```{r}
# creating a mesh with default settings
M1 <- point_mesh(template = "HCGSN256")
# plot output in 2D
plot_point_mesh(M1$D2)
```

```{r}
# creating a denser circular mesh, only 2D coordinates
M2 <- point_mesh(n = 30000, template = "HCGSN256", type = "circle")
# plotting a mesh - function allows different options of the result plot
plot_point_mesh(M2$D2, col.sensors = "purple", names = TRUE, cex = 0.1)
```

The graphic functions in `diegr` allow also the user to input the custom mesh created in other way, it is only necessary to maintain the structure following a `"mesh"` object.  
If the `mesh` input is not specified, the graphic functions automatically use the mesh created by `point_mesh` with default settings.

#### Topographical maps in 2D projection

The `topo_plot` function is used to plot a topographic map of the brain signal on the scalp, the amplitude values are colored using a topographic scale (with zero value always at the border of blue and green shades). 
The function allows setting some optionally arguments for editing the output appearance (with or without contours, sensor names, etc.) and further customization is for users available through output in the form of `ggplot` function. 

Notes: 

- The input values of `signal` outside the chosen `col.range` will cause "holes" in the resulting plot.

- To compare results for different subjects or conditions, setting the same values of \code{col.range} and \code{col.scale} arguments in all cases is necessary.

```{r}
# Plot average topographic map of signal for subject 1 from the time point 10
# (the time of the stimulus)
# the outlier epoch 14 is extracted before computing average

# a) preparing data
s1 <- epochdata |>
dplyr::filter(time == 10 & subject == 1 & !epoch %in% 14) |>
dplyr::select("signal", "sensor", "epoch") |>
dplyr::group_by(.data$sensor) |>
dplyr::mutate(average = mean(.data$signal, na.rm = TRUE))
s1 <- s1$average[1:204]

# plotting the topographic polygon map with contours and legend
# interval (-30,15) is selected in consideration of the signal progress
topo_plot(signal = s1, col.range = c(-30, 15), contour = TRUE)

# plotting the same map without contours and legend 
# but with sensor labels and adding the title
g1 <- topo_plot(signal = s1, col.range = c(-30, 15),
                names = TRUE, legend = FALSE)
g1 + ggplot2::ggtitle("Subject 1, time of the stimulus")
```


#### Topographical maps on the scalp

The `scalp_plot` function is created for plotting a scalp polygon map of the EEG signal amplitude using topographic colour scale (with zero value always at the border of blue and green shades). The result plot is rendered using `shape3d` function from package `rgl` and the signal interpolation between sensor locations is based on thin-plate spline interpolation model.  
Correct mesh triangulation is required for appropriate colours rendering. This triangulation is done through `make_triangulation` function which creates a Delaunay type-I triangulation (according Schumaker 2007) with consistent oriented edges.

The function allows setting the `col.range` argument, which is neccessary to obtain comparable results between different subjects or conditions. 

Note: The input values of `signal` outside the chosen `col.range` will cause "holes" in the resulting plot.

```{r, webgl=TRUE}
# preparing data - filtering signal from time point 10 (time of the stimulus) for subject 2,
# computing average from all epochs without outliers 14 and 15
s1 <- epochdata |>
dplyr::filter(.data$time == 10 & .data$subject == 2 & !.data$epoch %in% c(14,15)) |>
dplyr::select("signal", "sensor", "epoch") |>
dplyr::group_by(.data$sensor) |>
dplyr::mutate(average = mean(.data$signal, na.rm = TRUE))
s1 <- s1$average[1:204]

# plotting the scalp polygon map
#open3d()
scalp_plot(signal = s1, col.range = c(-30, 15))
```

The `rgl` output enables to zoom and rotate the image with default view of the back of the head.

#### References

Lai M-J, Schumaker LL. *Spline functions on triangulations.* Cambridge University Press; 2007.

Schneider PJ, Eberly DH. *Geometric Tools for Computer Graphics.* The Morgan Kaufmann Series in Computer Graphics. San Francisco: Morgan Kaufmann, 2003.



